<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>计算机网络面试题</title>
      <link href="2021/04/10/ji-suan-ji-wang-luo-mian-shi-ti/"/>
      <url>2021/04/10/ji-suan-ji-wang-luo-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<ol><li><p>主机之间的通信方式</p><p>客户-服务器（C/S）:客户是服务的请求方，服务器是服务的提供方。</p><p>对等(P2P):不区分客户和服务器</p></li></ol><ol start="2"><li><p>五层协议</p><p>应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。 </p><p>传输层 ：为进程提供通用数据传输服务。由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的 应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报 文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提 供完整性服务，UDP 主要提供及时性服务。</p><p> 网络层 ：为主机提供数据传输服务。而传输层协议是为主机中的进程提供数据传输服务。网络层把传输层传递 下来的报文段或者用户数据报封装成分组。</p><p> 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同 一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。 </p><p>物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽 传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410143808905.png" alt="image-20210410143808905"></p></li><li><p>OSI</p><p>表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。</p><p>会话层 ：建立及管理会话。</p></li></ol><ol start="5"><li><p>TCP/IP</p><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。</p><p> TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。</p></li></ol><ol start="6"><li><p>物理层通信方式</p><p>单工通信：单向传输 </p><p>半双工通信：双向交替传输 </p><p>全双工通信：双向同时传输</p></li></ol><ol start="7"><li><p>网络层</p><p>使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。</p></li></ol><ol start="8"><li><p>IP数据报格式</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410144400550.png" alt="image-20210410144400550"></p><p>版本 : 有 4（IPv4）和 6（IPv6）两个值； </p><p>首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度 为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 </p><p>区分服务 : 用来获得更好的服务，一般情况下不使用。</p><p>总长度 : 包括首部长度和数据部分长度。</p><p>生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 </p><p>协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。</p><p>首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算 的工作量。</p><p>标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 </p><p>片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。</p></li></ol><ol start="9"><li><p>IP地址编值方式</p><p>分类：</p><p>由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::= {&lt; 网络号 &gt;, &lt; 主机号 &gt;}</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410144818017.png" alt="image-20210410144818017"></p><p>子网划分：</p><p><strong>通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址</strong>。</p><p> IP 地址 ::= {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} </p><p>要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那 么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。</p><p>注意，外部网络看不到子网的存在。</p><p>无分类：</p><p>无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编 码，网络前缀的长度可以根据需要变化。 </p><p>IP 地址 ::= {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7/20 表示前 20 位为网络前缀。</p><p>CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。</p><p> 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路 由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚 合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹 配来确定应该匹配哪一个。</p></li></ol><ol start="10"><li><p>地址解析协议 ARP</p><p>网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP数据报的源地址和目的地址始终不变，而MAC地址随着链路的改变而改变。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410170545690.png" alt="image-20210410170545690"></p></li></ol><p>   <img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410170601966.png" alt="image-20210410170601966"></p><p>   每个主机都有一个ARP高速缓存，里面有本局域网上的各主机和路由器的IP地址到MAC地址的映射表。</p><p>​    如果主机A知道主机B的IP地址，但是ARP高速缓存中没有该IP地址到MAC地址的映射，此时主机A通过广播的方式发送AARP请求分组，主机B收到该请求后发送ARP响应分组给主机A告知其MAC地址，随后主机A向其高速缓存中写入主机B的IP地址到MAC地址的映射。</p><ol start="11"><li><p>网际控制报文协议 ICMP</p><p>ICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。</p></li></ol><p>   <img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171042199.png" alt="image-20210410171042199"></p><p>   ICMP 报文分为差错报告报文和询问报文。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171059878.png" alt="image-20210410171059878"></p><p>Ping </p><p>Ping 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间 和成功响应的次数估算出数据包往返时间以及丢包率。</p><p>Traceroute </p><p>Traceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。</p><p>源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一 个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超 过差错报告报文； </p><p>源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收 下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 </p><p>不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p><ol start="12"><li><p>虚拟专用网 VPN</p><p>由于 IP 地址的紧缺（原因），一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所 有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。</p><p>有三个专用地址块： </p><p>10.0.0.0 ~ 10.255.255.255 </p><p>172.16.0.0 ~ 172.31.255.255 </p><p>192.168.0.0 ~ 192.168.255.255</p><p>VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚 拟指好像是，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址 是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加 上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171328241.png" alt="image-20210410171328241"></p></li><li><p>网络地址转换 NAT</p><p>专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以<strong>使用 NAT 来将本地 IP 转换为全球 IP</strong>。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机 接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把传输层的端口号也用上了，使得多个专用网 内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。</p></li></ol><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171409845.png" alt="image-20210410171409845"></p><ol start="14"><li><p>路由器的结构</p><p>路由器从功能上可以划分为：路由选择和分组转发。</p><p>分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171803399.png" alt="image-20210410171803399"></p></li><li><p>路由器分组转发流程</p><p>从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。</p><p>若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； </p><p>若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； </p><p>若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； </p><p>若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； </p><p>报告转发分组出错。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410171902917.png" alt="image-20210410171902917"></p></li></ol><ol start="16"><li><p>路由选择协议</p><p>路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。</p><p>互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 </p><p>可以把路由选择协议划分为两大类： </p><p>自治系统内部的路由选择：RIP 和 OSPF </p><p>自治系统间的路由选择：BGP</p></li></ol><ol start="17"><li><p>UDP 和 TCP 的特点</p><p><strong>用户数据报</strong>协议 UDP（User Datagram Protocol）是<strong>无连接</strong>的，尽最大可能交付，没有拥塞控制，面向报文（对 于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交 互通信。</p><p><strong>传输控制协议</strong> TCP（Transmission Control Protocol）是<strong>面向连接</strong>的，提供<strong>可靠</strong>交付，有流量控制，拥塞控制，提 供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一 条 TCP 连接只能是点对点的（一对一）。</p></li></ol><ol start="18"><li><p>UDP首部格式</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410172554467.png" alt="image-20210410172554467"></p></li></ol><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。</p><ol start="19"><li><p>TCP首部格式</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410172633864.png" alt="image-20210410172633864"></p></li></ol><p>序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字 节，那么下一个报文段的序号应为 401。 </p><p>确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据 长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 </p><p>数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</p><p> 确认 ACK ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 </p><p>同步 SYN ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立 连接，则响应报文中 SYN=1，ACK=1。 </p><p>终止 FIN ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 </p><p>窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空 间是有限的。</p><ol start="20"><li><p>TCP的三次握手</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410172745968.png" alt="image-20210410172745968"></p></li></ol><p>假设 A 为客户端，B 为服务器端。 </p><p>首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 </p><p>A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。</p><p>B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选 择一个初始的序号 y。 </p><p>A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 </p><p>B 收到 A 的确认后，连接建立。</p><ol start="21"><li><p>三次握手的原因</p><p>第三次握手时为了防止失效的连接请求到达服务器，让服务器错误打开连接。</p><p>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p></li></ol><ol start="22"><li><p>域名系统DNS</p><p>DNS 是一个<strong>分布式数据库</strong>，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保 留它自己的那部分数据。</p><p>域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。</p><p><img src="C:\Users\L\AppData\Roaming\Typora\typora-user-images\image-20210410173517213.png" alt="image-20210410173517213"></p></li></ol><ol start="23"><li><p>文件传送协议FTP</p><p>FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件：</p><p>控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传 送给服务器，并传回服务器的应答。 </p><p>数据连接：用来传送一个文件数据。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务端面试题</title>
      <link href="2021/04/07/how2jee/"/>
      <url>2021/04/07/how2jee/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端面试题"><a href="#服务端面试题" class="headerlink" title="服务端面试题"></a>服务端面试题</h2><ul><li><p>9种隐式对象，以及他们的用途</p><p>JSP一共有9个隐式对象，分别是<br><strong>request,response,out</strong><br>分别代表请求，响应和输出</p><p><strong>pageContext, session,application</strong><br>pageContext 代表当前页面作用域<br>session 代表当会话作用域<br>application 代表当全局作用域</p><p><strong>config</strong><br>config可以获取一些在web.xml中初始化的参数.</p><p><strong>page</strong><br>表示当前对象</p><p><strong>exception</strong><br>表示异常对象.</p></li></ul><ul><li><p>3种JSP的指令</p><p><a href="https://how2j.cn/k/jsp/jsp-tutorials/530.html#step1651">&lt;%@page</a><br>JSP的基本设置，比如编码方式，import其他类，是否开启EL表达式</p><p><a href="https://how2j.cn/k/jsp/jsp-include/576.html">&lt;%@include</a><br>包含其他的文件</p><p><a href="https://how2j.cn/k/jsp/jsp-jstl/578.html">&lt;%@taglib</a><br>使用标签库</p></li></ul><ul><li><p>2种JSP的动作</p><p>&lt;jsp:forword<br>服务端跳转</p><p>&lt;jsp:include<br>包含其他文件</p></li></ul><ul><li><p>doGet()和 doPost的区别，分别在什么情况下调用</p><p>doGet和doPost都是在<a href="https://how2j.cn/k/servlet/servlet-service/549.html">service()</a>方法后调用的，分别来处理method=”get”和method=”post”的请求</p></li></ul><ul><li><p>servlet的init方法和service方法的区别</p><p>在Servlet的生命周期中，先调用init进行初始化，而且只调用一次。</p><p>接着再调用service,有多少次请求，就调用多少次service</p></li></ul><ul><li><p>servlet的生命周期</p><p>一个Servlet的生命周期由 <a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1594">实例化</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1595">初始化</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1596">提供服务</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1597">销毁</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1597">被回收</a> 几个步骤组成</p><p><img src="https://stepimagewm.how2j.cn/1735.png" alt="servlet的生命周期"></p></li></ul><ul><li><p>页面间对象传递的方法</p><p>假设是a.jsp传递数据到b.jsp，那么页面间对象传递的方式有如下几种</p><ol><li><p>在a.jsp中request.setAttribute，然后<strong>服务端跳转</strong>到b.jsp</p></li><li><p>在a.jsp中session.setAttribute，然后跳转到b.jsp, 无所谓客户端还是服务端跳转</p></li><li><p>在a.jsp中application.setAttribute, 然后跳转到b.jsp，无所谓客户端还是服务端跳转</p></li></ol></li></ul><ul><li><p>Request常见方法</p><p><strong>request.getRequestURL():</strong> 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +</p><p><strong>request.getRequestURI():</strong> 浏览器发出请求的资源名部分，去掉了协议和主机名” +</p><p><strong>request.getQueryString():</strong> 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到</p><p><strong>request.getRemoteAddr():</strong> 浏览器所处于的客户机的IP地址</p><p><strong>request.getRemoteHost():</strong> 浏览器所处于的客户机的主机名</p><p><strong>request.getRemotePort():</strong> 浏览器所处于的客户机使用的网络端口</p><p><strong>request.getLocalAddr():</strong> 服务器的IP地址</p><p><strong>request.getLocalName():</strong> 服务器的主机名</p><p><strong>request.getMethod():</strong> 得到客户机请求方式一般是GET或者POST</p></li></ul><ul><li><p>J2EE是技术，还是平台，还是框架</p><p>是<strong>平台</strong>，上面运行各种各样的技术(servlet,jsp,filter,listner)和框架(struts,hibernate,spring)</p></li></ul><ul><li><p>编写JavaBean的注意事项</p><p>JavaBean就是实体类<br>无参构造方法<br>属性都用private修饰，并且都有public的getter和setter</p></li></ul><ul><li><p>MVC的各个部分都有哪些技术来实现，分别如何实现</p><p>M 模型层代表数据，使用bean,dao等等<br>V 视图层代表展现，使用html,jsp,css<br>C 控制层代表控制，使用servlet</p></li></ul><ul><li><p>JSP中两种include的区别</p><p>一种是静态包含，一种是动态包含</p></li></ul><ul><li><p>简述你对简单Servlet、过滤器、监听器的理解</p><p>Servlet的作用是处理获取参数，处理业务，页面跳转</p><p>过滤器（filter）的作用是拦截请求，一般会有做编码处理，登录权限验证</p><p>监听器（listner）的作用是监听Request，Session，Context等等的生命周期，以及其中数据的变化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 面试题</title>
      <link href="2021/04/05/java-mian-shi-ti/"/>
      <url>2021/04/05/java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-面试题"><a href="#JAVA-面试题" class="headerlink" title="JAVA 面试题"></a>JAVA 面试题</h2><ul><li><p>面向对象的特征有哪些方面？</p><p>封装，继承，多态，抽象</p><p><strong>封装：</strong></p><p>把属性私有化封装在一个类里面，只能通过方法去访问。</p><p><strong>继承</strong></p><p>子类继承父类，从而继承父类的方法和属性。</p><p><strong>多态</strong></p><p>多态分为操作符的多态和类的多态。类的多态指父类引用指向子类对象，并且有继承，有重写。</p><p><strong>抽象</strong></p><p>比如一个英雄类，<strong>抽象</strong>出了name,hp这些属性，使得开发过程中更加易于理解</p></li><li><p>String是最基本的数据类型吗？</p><p>String是类类型，不是基本类型。<br>[基本类型]有八种<br>这八种基本类型分别是：<br>整型 （4种）<br>字符型 （1种）<br>浮点型 （2种）<br>布尔型（1种）</p></li><li><p>int 和 Integer 有什么区别？</p><p>int是基本类型32位长度的整数</p><p>Integer是类类型，是int的封装类</p><p>int和Integer之间可以通过自动装箱 自动拆箱 互相转换</p></li><li><p>String 和StringBuffer的区别？</p><p>String是immutable的,其内容一旦创建好之后，就不可以发生改变。<br>StringBuffer 是可以变长的，内容也可以发生改变<br>改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。<br>更多细节可以参考 模仿StringBuffer的 MyStringBuffer类是如何实现的。</p></li><li><p>运行时异常与一般异常有何异同？</p><p>[运行时异常]又叫做非可查异常，在编译过程中，不要求必须进行显示捕捉<br>[一般异常]又叫做可查异常，在编译过程中，必须进行处理，要么捕捉，要么通过throws抛出去</p></li><li><p>说出ArrayList,Vector, LinkedList的存储性能和特性</p><p>ArrayList和Vector：</p><p>​    两者都继承抽象类AbstractList，但是Vector是线程安全的，而ArrayList是非线程安全的</p><p>ArrayList和LinkedList的区别</p><p>​    ArrayList 是数组结构，所以定位很快，但是插入和删除很慢</p><p>​    LinkedList 是双向链表结构，所以插入和删除很快，但是定位很慢</p></li><li><p>Collection 和 Collections的区别</p><p>Collection是接口，是List和Set的父接口<br>Collections是工具类，提供了排序，混淆等等很多实用方法</p></li><li><p>&amp;和&amp;&amp;的区别</p><p>&amp; 有两个作用，分别是 位与 和 逻辑与</p><p>&amp;&amp; 就是逻辑与<br>作为逻辑与， <strong>&amp; 和 &amp;&amp; 分别表示长路与和短路与</strong><br><strong>长路与</strong> 两侧，都会被运算<br><strong>短路与</strong> 只要第一个是false，第二个就不进行运算了</p></li><li><p>HashMap和Hashtable的区别</p><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式</p><p>区别1：</p><pre><code>HashMap可以存放 nullHashtable不能存放null</code></pre><p>区别2：</p><pre><code>HashMap不是线程安全的类Hashtable是线程安全的类</code></pre></li><li><p>final, finally, finalize的区别</p><p>final</p><p>​    final修饰类，方法，基本类型变量，引用的时候分别有不同的意思<br>​    修饰类 表示该类不能被继承<br>​    修饰方法 表示该方法不能被重写<br>​    修饰基本类型变量 表示该变量只能被赋值一次<br>​    修饰引用 表示该引用只有一次指向对象的机会</p><p>finally</p><p>​    finally 是用于异常处理的场面，无论是否有异常抛出，都会执行</p><p>finalize</p><p>​    finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p></li><li><p>Error和Exception有什么区别?</p><p>Error和Exception都实现了Throwable接口</p><p>Error指的是JVM层面的错误，比如内存不足OutOfMemoryError</p><p>Exception指的是代码逻辑的异常，比如下标越界OutOfIndexException</p></li><li><p>abstract class和interface有什么区别?</p><p>abstract class 抽象类和interface接口的区别：</p><p>使用方式：</p><pre><code>**抽象类只能够通过继承被使用**接口必须通过**实现**被使用</code></pre><p>实现方法：</p><pre><code>抽象类不仅可以提供抽象方法，也可以提供实现方法接口只能提供抽象方法，不能提供实现方法。 但是在JAVA8版本开始，接口可以提供实现方法了，前提    是要在方法前加一个default修饰符</code></pre></li><li><p>heap和stack有什么区别？</p><p>heap: 堆</p><p>stack: 栈</p><p>存放的内容不一样：<br>heap: 是存放对象的<br>stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用</p><p>存取方式不一样：<br>heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢<br>stack: 是固定大小的，并且是FILO 先入后出的顺序，并且存取速度比较快</p></li></ul><ul><li><p>GC是什么? 为什么要有GC?</p><p>GC是Garbage Collection的缩写，即<strong>垃圾回收</strong><br>这里所谓的垃圾，指的是那些不再被使用的对象，JVM的垃圾回收机制使得开发人员从无聊、容易犯错的手动释放内存资源的过程中解放出来。<br>开发人员可以<strong>更加专注的进行业务功能的开发</strong>，而资源回收的工作交由更加专业的垃圾回收机制自动完成。</p></li></ul><ul><li><p>short s1 = 1; s1 = s1 + 1;有什么错?</p><p>short s1 = 1; 这一句没有错误，编译器会自动把1这个整数处理为short.<br>s1 = s1 + 1; 右侧的表达式会返回一个Int类型的整数，再把这个int类型的整数赋给short类型的s1的时候，就会出现强制转换错误。</p></li></ul><ul><li><p>接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类（concrete class）？</p><p>接口是否可继承接口?<br>可以，比如List 就继承了接口Collection</p><p>抽象类是否可实现(implements)接口?<br>可以，比如 MouseAdapter鼠标监听适配器是一个抽象类，并且实现了MouseListener接口</p><p>抽象类是否可继承实体类（concrete class）？<br>可以，所有抽象类，都继承了Object</p></li></ul><ul><li><p>List, Set, Map是否继承自Collection接口?</p><p>List 和 Set 继承了Collection接口</p><p>但是Map和Collection之间没有继承关系，因为一个是键值对容器，一个是单值容器，无法兼容</p><p><img src="https://stepimagewm.how2j.cn/1960.png" alt="List, Set, Map是否继承自Collection接口?"></p></li></ul><ul><li><p>数组有没有length()这个方法? String有没有length()这个方法？</p><p>数组获取长度的手段是 .length 属性</p><p>String获取长度的手段是 length()方法</p><p>集合获取长度的手段是 size()方法</p><p>文件获取长度的手段是 length()方法</p></li></ul><ul><li><p>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？</p><p>以HashSet为例，判断重复的逻辑是：</p><ol><li>首先看hashcode是否相同，如果不同，就是不重复的</li><li>如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的。</li></ol></li></ul><ul><li>构造器Constructor是否可被override?是否可以继承String类?</li></ul><p>​     子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。</p><ul><li><p>垃圾回收的优点和原理。并考虑2种回收机制。</p><p>与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。</p><p>原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。</p><p>两种常见的回收机制：</p><ol><li><p>定时回收<br>每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢</p></li><li><p>当垃圾占到某个百分比的时候，进行回收<br>比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。</p></li></ol><p>一般说来 JVM会采用两种机制结合的方式进行垃圾回收。与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。</p><p>原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。</p><p>两种常见的回收机制：</p><ol><li><p>定时回收<br>每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢</p></li><li><p>当垃圾占到某个百分比的时候，进行回收<br>比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。</p></li></ol><p>一般说来 JVM会采用两种机制结合的方式进行垃圾回收。</p></li></ul><ul><li><p>你所知道的集合类都有哪些？主要方法？</p><p>常见的集合<br>ArrayList,LinkedList,HashSet,HashMap,TreeSet 等等<br>常见方法：<br>size()<br>add()<br>remove()<br>等等</p></li></ul><ul><li><p>关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</p><p>throws 用在方法声明上面，表示该方法有可能抛出某个异常<br>throw 抛出一个指定的异常<br>try catch 在try中有可能会抛出某个异常，一旦某个异常抛出后，就会在catch中进行捕捉，他俩<strong>一般说来</strong>都是成对出现的。<br>finally 表示无论是否捕捉住异常，都会执行</p></li></ul><ul><li><p>java中实现多态的机制是什么？</p><p>类的多态的条件：</p><ol><li>父类（接口）引用指向子类对象</li><li>方法有重写</li></ol></li></ul><ul><li><p>静态变量和实例变量的区别？</p><p>静态变量 直接通过类就可以访问，无需实例</p><p>实例变量 比如通过类的某个具体实例，才可以访问</p></li></ul><ul><li><p>在JAVA中，如何跳出当前的多重嵌套循环？</p><p>在外部循环的前一行，加上标签<br>在break的时候使用该标签<br>即能达到结束多重嵌套循环的效果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">//打印单数    </span>        outloop<span class="token operator">:</span> <span class="token comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>j<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span>                     <span class="token keyword">break</span> outloop<span class="token punctuation">;</span> <span class="token comment">//如果是双数，结束外部循环</span>            <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>List、Map、Set三个接口，存取元素时，各有什么特点？</p><p>List 是有顺序的，并且可以重复<br>Set 是无序的，不可以重复<br>Map 保存数据的方式是键值对</p></li><li><p>内部类可以引用外部类的成员吗？有没有什么限制？</p><p>可以使用<br>如果是非静态内部类，可以使用外部类的所有成员<br>如果是静态内部类，只能使用外部类的静态成员</p></li></ul><ul><li><p>多线程有几种实现方法,都是什么？</p><p>通常来讲，Java 创建一个线程有三种方式</p><ol><li>继承一个Thread类</li><li>实现Runnable接口</li><li>匿名内部类</li></ol></li></ul><ul><li><p>sleep() 和 wait() 有什么区别?</p><p>首先sleep和wait之间没有任何关系</p><p>sleep 是Thread类的方法，指的是<strong>当前线程暂停</strong>。</p><p>wait 是Object类的方法， 指的占用<strong>当前对象的线程临时释放对当前对象的占用</strong>，以使得其他线程有机会占用当前对象。 所以调用wait方法一定是在synchronized 中进行</p></li></ul><ul><li><p>说出数据连接池的工作机制是什么?</p><p>数据库连接池原理：<br>因为创建连接和关闭连接的行为是非常耗时的，会显著降低软件的性能表现。解决办法就是先创建 n 条数据库连接Connection，循环使用，但是不进行关闭，这样再执行SQL语句，就不需要额外创建连接了，直接使用现成的连接就可以了，从而节约了创建连接和关闭连接的时间开销。</p></li></ul><ul><li><p>简述synchronized和java.util.concurrent.locks.Lock的异同 ？</p><ol><li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p></li><li><p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p></li><li><p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的个性化配置</title>
      <link href="2021/04/03/mo-ban/"/>
      <url>2021/04/03/mo-ban/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>服务端面试题</title>
      <link href="2021/04/07/how2jee/"/>
      <url>2021/04/07/how2jee/</url>
      
        <content type="html"><![CDATA[<h2 id="服务端面试题"><a href="#服务端面试题" class="headerlink" title="服务端面试题"></a>服务端面试题</h2><ul><li><p>9种隐式对象，以及他们的用途</p><p>JSP一共有9个隐式对象，分别是<br><strong>request,response,out</strong><br>分别代表请求，响应和输出</p><p><strong>pageContext, session,application</strong><br>pageContext 代表当前页面作用域<br>session 代表当会话作用域<br>application 代表当全局作用域</p><p><strong>config</strong><br>config可以获取一些在web.xml中初始化的参数.</p><p><strong>page</strong><br>表示当前对象</p><p><strong>exception</strong><br>表示异常对象.</p></li></ul><ul><li><p>3种JSP的指令</p><p><a href="https://how2j.cn/k/jsp/jsp-tutorials/530.html#step1651">&lt;%@page</a><br>JSP的基本设置，比如编码方式，import其他类，是否开启EL表达式</p><p><a href="https://how2j.cn/k/jsp/jsp-include/576.html">&lt;%@include</a><br>包含其他的文件</p><p><a href="https://how2j.cn/k/jsp/jsp-jstl/578.html">&lt;%@taglib</a><br>使用标签库</p></li></ul><ul><li><p>2种JSP的动作</p><p>&lt;jsp:forword<br>服务端跳转</p><p>&lt;jsp:include<br>包含其他文件</p></li></ul><ul><li><p>doGet()和 doPost的区别，分别在什么情况下调用</p><p>doGet和doPost都是在<a href="https://how2j.cn/k/servlet/servlet-service/549.html">service()</a>方法后调用的，分别来处理method=”get”和method=”post”的请求</p></li></ul><ul><li><p>servlet的init方法和service方法的区别</p><p>在Servlet的生命周期中，先调用init进行初始化，而且只调用一次。</p><p>接着再调用service,有多少次请求，就调用多少次service</p></li></ul><ul><li><p>servlet的生命周期</p><p>一个Servlet的生命周期由 <a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1594">实例化</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1595">初始化</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1596">提供服务</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1597">销毁</a>，<a href="https://how2j.cn/k/servlet/servlet-lifecycle/550.html#step1597">被回收</a> 几个步骤组成</p><p><img src="https://stepimagewm.how2j.cn/1735.png" alt="servlet的生命周期"></p></li></ul><ul><li><p>页面间对象传递的方法</p><p>假设是a.jsp传递数据到b.jsp，那么页面间对象传递的方式有如下几种</p><ol><li><p>在a.jsp中request.setAttribute，然后<strong>服务端跳转</strong>到b.jsp</p></li><li><p>在a.jsp中session.setAttribute，然后跳转到b.jsp, 无所谓客户端还是服务端跳转</p></li><li><p>在a.jsp中application.setAttribute, 然后跳转到b.jsp，无所谓客户端还是服务端跳转</p></li></ol></li></ul><ul><li><p>Request常见方法</p><p><strong>request.getRequestURL():</strong> 浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)” +</p><p><strong>request.getRequestURI():</strong> 浏览器发出请求的资源名部分，去掉了协议和主机名” +</p><p><strong>request.getQueryString():</strong> 请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到</p><p><strong>request.getRemoteAddr():</strong> 浏览器所处于的客户机的IP地址</p><p><strong>request.getRemoteHost():</strong> 浏览器所处于的客户机的主机名</p><p><strong>request.getRemotePort():</strong> 浏览器所处于的客户机使用的网络端口</p><p><strong>request.getLocalAddr():</strong> 服务器的IP地址</p><p><strong>request.getLocalName():</strong> 服务器的主机名</p><p><strong>request.getMethod():</strong> 得到客户机请求方式一般是GET或者POST</p></li></ul><ul><li><p>J2EE是技术，还是平台，还是框架</p><p>是<strong>平台</strong>，上面运行各种各样的技术(servlet,jsp,filter,listner)和框架(struts,hibernate,spring)</p></li></ul><ul><li><p>编写JavaBean的注意事项</p><p>JavaBean就是实体类<br>无参构造方法<br>属性都用private修饰，并且都有public的getter和setter</p></li></ul><ul><li><p>MVC的各个部分都有哪些技术来实现，分别如何实现</p><p>M 模型层代表数据，使用bean,dao等等<br>V 视图层代表展现，使用html,jsp,css<br>C 控制层代表控制，使用servlet</p></li></ul><ul><li><p>JSP中两种include的区别</p><p>一种是静态包含，一种是动态包含</p></li></ul><ul><li><p>简述你对简单Servlet、过滤器、监听器的理解</p><p>Servlet的作用是处理获取参数，处理业务，页面跳转</p><p>过滤器（filter）的作用是拦截请求，一般会有做编码处理，登录权限验证</p><p>监听器（listner）的作用是监听Request，Session，Context等等的生命周期，以及其中数据的变化</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA 面试题</title>
      <link href="2021/04/05/java-mian-shi-ti/"/>
      <url>2021/04/05/java-mian-shi-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-面试题"><a href="#JAVA-面试题" class="headerlink" title="JAVA 面试题"></a>JAVA 面试题</h2><ul><li><p>面向对象的特征有哪些方面？</p><p>封装，继承，多态，抽象</p><p><strong>封装：</strong></p><p>把属性私有化封装在一个类里面，只能通过方法去访问。</p><p><strong>继承</strong></p><p>子类继承父类，从而继承父类的方法和属性。</p><p><strong>多态</strong></p><p>多态分为操作符的多态和类的多态。类的多态指父类引用指向子类对象，并且有继承，有重写。</p><p><strong>抽象</strong></p><p>比如一个英雄类，<strong>抽象</strong>出了name,hp这些属性，使得开发过程中更加易于理解</p></li><li><p>String是最基本的数据类型吗？</p><p>String是类类型，不是基本类型。<br>[基本类型]有八种<br>这八种基本类型分别是：<br>整型 （4种）<br>字符型 （1种）<br>浮点型 （2种）<br>布尔型（1种）</p></li><li><p>int 和 Integer 有什么区别？</p><p>int是基本类型32位长度的整数</p><p>Integer是类类型，是int的封装类</p><p>int和Integer之间可以通过自动装箱 自动拆箱 互相转换</p></li><li><p>String 和StringBuffer的区别？</p><p>String是immutable的,其内容一旦创建好之后，就不可以发生改变。<br>StringBuffer 是可以变长的，内容也可以发生改变<br>改变的原理是StringBuffer内部采用了字符数组存放数据，在需要增加长度的时候，创建新的数组，并且把原来的数据复制到新的数组这样的办法来实现。<br>更多细节可以参考 模仿StringBuffer的 MyStringBuffer类是如何实现的。</p></li><li><p>运行时异常与一般异常有何异同？</p><p>[运行时异常]又叫做非可查异常，在编译过程中，不要求必须进行显示捕捉<br>[一般异常]又叫做可查异常，在编译过程中，必须进行处理，要么捕捉，要么通过throws抛出去</p></li><li><p>说出ArrayList,Vector, LinkedList的存储性能和特性</p><p>ArrayList和Vector：</p><p>​    两者都继承抽象类AbstractList，但是Vector是线程安全的，而ArrayList是非线程安全的</p><p>ArrayList和LinkedList的区别</p><p>​    ArrayList 是数组结构，所以定位很快，但是插入和删除很慢</p><p>​    LinkedList 是双向链表结构，所以插入和删除很快，但是定位很慢</p></li><li><p>Collection 和 Collections的区别</p><p>Collection是接口，是List和Set的父接口<br>Collections是工具类，提供了排序，混淆等等很多实用方法</p></li><li><p>&amp;和&amp;&amp;的区别</p><p>&amp; 有两个作用，分别是 位与 和 逻辑与</p><p>&amp;&amp; 就是逻辑与<br>作为逻辑与， <strong>&amp; 和 &amp;&amp; 分别表示长路与和短路与</strong><br><strong>长路与</strong> 两侧，都会被运算<br><strong>短路与</strong> 只要第一个是false，第二个就不进行运算了</p></li><li><p>HashMap和Hashtable的区别</p><p>HashMap和Hashtable都实现了Map接口，都是键值对保存数据的方式</p><p>区别1：</p><pre><code>HashMap可以存放 nullHashtable不能存放null</code></pre><p>区别2：</p><pre><code>HashMap不是线程安全的类Hashtable是线程安全的类</code></pre></li><li><p>final, finally, finalize的区别</p><p>final</p><p>​    final修饰类，方法，基本类型变量，引用的时候分别有不同的意思<br>​    修饰类 表示该类不能被继承<br>​    修饰方法 表示该方法不能被重写<br>​    修饰基本类型变量 表示该变量只能被赋值一次<br>​    修饰引用 表示该引用只有一次指向对象的机会</p><p>finally</p><p>​    finally 是用于异常处理的场面，无论是否有异常抛出，都会执行</p><p>finalize</p><p>​    finalize是Object的方法，所有类都继承了该方法。 当一个对象满足垃圾回收的条件，并且被回收的时候，其finalize()方法就会被调用</p></li><li><p>Error和Exception有什么区别?</p><p>Error和Exception都实现了Throwable接口</p><p>Error指的是JVM层面的错误，比如内存不足OutOfMemoryError</p><p>Exception指的是代码逻辑的异常，比如下标越界OutOfIndexException</p></li><li><p>abstract class和interface有什么区别?</p><p>abstract class 抽象类和interface接口的区别：</p><p>使用方式：</p><pre><code>**抽象类只能够通过继承被使用**接口必须通过**实现**被使用</code></pre><p>实现方法：</p><pre><code>抽象类不仅可以提供抽象方法，也可以提供实现方法接口只能提供抽象方法，不能提供实现方法。 但是在JAVA8版本开始，接口可以提供实现方法了，前提    是要在方法前加一个default修饰符</code></pre></li><li><p>heap和stack有什么区别？</p><p>heap: 堆</p><p>stack: 栈</p><p>存放的内容不一样：<br>heap: 是存放对象的<br>stack: 是存放基本类型(int, float, boolean 等等)、引用(对象地址)、方法调用</p><p>存取方式不一样：<br>heap: 是自动增加大小的，所以不需要指定大小，但是存取相对较慢<br>stack: 是固定大小的，并且是FILO 先入后出的顺序，并且存取速度比较快</p></li></ul><ul><li><p>GC是什么? 为什么要有GC?</p><p>GC是Garbage Collection的缩写，即<strong>垃圾回收</strong><br>这里所谓的垃圾，指的是那些不再被使用的对象，JVM的垃圾回收机制使得开发人员从无聊、容易犯错的手动释放内存资源的过程中解放出来。<br>开发人员可以<strong>更加专注的进行业务功能的开发</strong>，而资源回收的工作交由更加专业的垃圾回收机制自动完成。</p></li></ul><ul><li><p>short s1 = 1; s1 = s1 + 1;有什么错?</p><p>short s1 = 1; 这一句没有错误，编译器会自动把1这个整数处理为short.<br>s1 = s1 + 1; 右侧的表达式会返回一个Int类型的整数，再把这个int类型的整数赋给short类型的s1的时候，就会出现强制转换错误。</p></li></ul><ul><li><p>接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承实体类（concrete class）？</p><p>接口是否可继承接口?<br>可以，比如List 就继承了接口Collection</p><p>抽象类是否可实现(implements)接口?<br>可以，比如 MouseAdapter鼠标监听适配器是一个抽象类，并且实现了MouseListener接口</p><p>抽象类是否可继承实体类（concrete class）？<br>可以，所有抽象类，都继承了Object</p></li></ul><ul><li><p>List, Set, Map是否继承自Collection接口?</p><p>List 和 Set 继承了Collection接口</p><p>但是Map和Collection之间没有继承关系，因为一个是键值对容器，一个是单值容器，无法兼容</p><p><img src="https://stepimagewm.how2j.cn/1960.png" alt="List, Set, Map是否继承自Collection接口?"></p></li></ul><ul><li><p>数组有没有length()这个方法? String有没有length()这个方法？</p><p>数组获取长度的手段是 .length 属性</p><p>String获取长度的手段是 length()方法</p><p>集合获取长度的手段是 size()方法</p><p>文件获取长度的手段是 length()方法</p></li></ul><ul><li><p>Set里的元素是不能重复的，那么用什么方法来区分重复与否呢？</p><p>以HashSet为例，判断重复的逻辑是：</p><ol><li>首先看hashcode是否相同，如果不同，就是不重复的</li><li>如果hashcode一样，再比较equals，如果不同，就是不重复的，否则就是重复的。</li></ol></li></ul><ul><li>构造器Constructor是否可被override?是否可以继承String类?</li></ul><p>​     子类不能继承父类的构造方法，所以就不存在重写父类的构造方法。</p><ul><li><p>垃圾回收的优点和原理。并考虑2种回收机制。</p><p>与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。</p><p>原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。</p><p>两种常见的回收机制：</p><ol><li><p>定时回收<br>每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢</p></li><li><p>当垃圾占到某个百分比的时候，进行回收<br>比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。</p></li></ol><p>一般说来 JVM会采用两种机制结合的方式进行垃圾回收。与C语言开发人员需要手动进行内存资源的释放不同，Java提供垃圾回收机制，自动进行GC，将开发人员从容易犯错的内存资源管理中解放出来。</p><p>原理：当某个一个对象，没有任何引用指向它的时候，那么它就满足垃圾回收的条件，在适当的时候，JVM虚拟机进行GC将其回收，释放空间，以供后续再利用。</p><p>两种常见的回收机制：</p><ol><li><p>定时回收<br>每隔30分钟进行一次回收，这种机制的弊端是如果垃圾产生的比较快，有可能30分钟之内垃圾已经把内存占用光了，导致性能变慢</p></li><li><p>当垃圾占到某个百分比的时候，进行回收<br>比如，当垃圾占到70%的时候，进行回收。 这种机制的弊端是，如果垃圾产生的频率很快，那么JVM就必须高频率的进行垃圾回收。 而在垃圾回收的过程中， JVM会停顿下来，只做垃圾回收，而影响业务功能的正常运行。</p></li></ol><p>一般说来 JVM会采用两种机制结合的方式进行垃圾回收。</p></li></ul><ul><li><p>你所知道的集合类都有哪些？主要方法？</p><p>常见的集合<br>ArrayList,LinkedList,HashSet,HashMap,TreeSet 等等<br>常见方法：<br>size()<br>add()<br>remove()<br>等等</p></li></ul><ul><li><p>关键字：throws,throw,try,catch,finally分别代表什么意义？在try块中可以抛出异常吗？</p><p>throws 用在方法声明上面，表示该方法有可能抛出某个异常<br>throw 抛出一个指定的异常<br>try catch 在try中有可能会抛出某个异常，一旦某个异常抛出后，就会在catch中进行捕捉，他俩<strong>一般说来</strong>都是成对出现的。<br>finally 表示无论是否捕捉住异常，都会执行</p></li></ul><ul><li><p>java中实现多态的机制是什么？</p><p>类的多态的条件：</p><ol><li>父类（接口）引用指向子类对象</li><li>方法有重写</li></ol></li></ul><ul><li><p>静态变量和实例变量的区别？</p><p>静态变量 直接通过类就可以访问，无需实例</p><p>实例变量 比如通过类的某个具体实例，才可以访问</p></li></ul><ul><li><p>在JAVA中，如何跳出当前的多重嵌套循环？</p><p>在外部循环的前一行，加上标签<br>在break的时候使用该标签<br>即能达到结束多重嵌套循环的效果</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token comment">//打印单数    </span>        outloop<span class="token operator">:</span> <span class="token comment">//outloop这个标示是可以自定义的比如outloop1,ol2,out5</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token string">":"</span><span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token operator">==</span>j<span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span>                     <span class="token keyword">break</span> outloop<span class="token punctuation">;</span> <span class="token comment">//如果是双数，结束外部循环</span>            <span class="token punctuation">}</span>                      <span class="token punctuation">}</span>              <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ul><ul><li><p>List、Map、Set三个接口，存取元素时，各有什么特点？</p><p>List 是有顺序的，并且可以重复<br>Set 是无序的，不可以重复<br>Map 保存数据的方式是键值对</p></li><li><p>内部类可以引用外部类的成员吗？有没有什么限制？</p><p>可以使用<br>如果是非静态内部类，可以使用外部类的所有成员<br>如果是静态内部类，只能使用外部类的静态成员</p></li></ul><ul><li><p>多线程有几种实现方法,都是什么？</p><p>通常来讲，Java 创建一个线程有三种方式</p><ol><li>继承一个Thread类</li><li>实现Runnable接口</li><li>匿名内部类</li></ol></li></ul><ul><li><p>sleep() 和 wait() 有什么区别?</p><p>首先sleep和wait之间没有任何关系</p><p>sleep 是Thread类的方法，指的是<strong>当前线程暂停</strong>。</p><p>wait 是Object类的方法， 指的占用<strong>当前对象的线程临时释放对当前对象的占用</strong>，以使得其他线程有机会占用当前对象。 所以调用wait方法一定是在synchronized 中进行</p></li></ul><ul><li><p>说出数据连接池的工作机制是什么?</p><p>数据库连接池原理：<br>因为创建连接和关闭连接的行为是非常耗时的，会显著降低软件的性能表现。解决办法就是先创建 n 条数据库连接Connection，循环使用，但是不进行关闭，这样再执行SQL语句，就不需要额外创建连接了，直接使用现成的连接就可以了，从而节约了创建连接和关闭连接的时间开销。</p></li></ul><ul><li><p>简述synchronized和java.util.concurrent.locks.Lock的异同 ？</p><ol><li><p>Lock是一个接口，而synchronized是Java中的关键字，synchronized是内置的语言实现，Lock是代码层面的实现。</p></li><li><p>Lock可以选择性的获取锁，如果一段时间获取不到，可以放弃。synchronized不行，会一根筋一直获取下去。 借助Lock的这个特性，就能够规避死锁，synchronized必须通过谨慎和良好的设计，才能减少死锁的发生。</p></li><li><p>synchronized在发生异常和同步块结束的时候，会自动释放锁。而Lock必须手动释放， 所以如果忘记了释放锁，一样会造成死锁。</p></li></ol></li></ul>]]></content>
      
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的个性化配置</title>
      <link href="2021/04/03/mo-ban/"/>
      <url>2021/04/03/mo-ban/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
